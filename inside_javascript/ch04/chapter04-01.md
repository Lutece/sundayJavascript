## 4.1 함수 정의
자바스크립트에서 함수를 생성하는 방법은 3가지가 있다.  
이들 방식은 모두 같은 함수를 생성하지만, 각각의 방식에 따라 함수 동작이 미모하게 차이가 난다.
- 함수 선언문 (function statement)
- 함수 표현식 (function expresstion)
- Function() 생성자 함수


### 4.1.1 함수 리터럴
자바스크립트에서는 함수도 일반 객체처럼 값으로 취급니다.  
때문에 객체 리터럴 방식으로 일반 객체를 생성할 수 있는 것처럼, 자바스크립트에서는 **함수 리터럴** 을 이용해 함수를 생성할 수 있다.  
실제로 함수 선언문이나 함수 표현식 방법 모두 이런 함수 리터럴 방식으로 함수를 생성한다.
```js
//함수 리터럴을 통한 add() 함수 정의
function add(x, y){
    return x = y;
}
```
함수 리터럴은 위 예제와 같이 크게 4가지로 구성된다.
1. function 키워드 : 자바스크립트 함수 리터럴은 function 키워드로 시작한다.
2. 함수명 : 함수명은 함수 몸체의 내부 코드에서 자신을 재귀적으로 호출하거나 또는 자바스크립트 디버거가 해당함수를 구분하는 식별자로 사용된다.  
여기서 주목할 점은 함수명은 선택 사항이라는 것이다.  
자바스크립트에서는 함수명이 없는 함수를 익명 함수라 한다.
3. 매개변수 리스트 : 매개변수는 C 언어와 같은 기존 언어의 함수 매개변수 형태와 거의 비슷하지만, 매개변수 타입을 기술하지 않는다는 차이가 있다.
4. 함수 몸체 : 실제 함수가 호출됐을 때 실행되는 코드 부분이다.

### 4.1.2  함수 선언문 방식으로 함수 생성하기
함수 선언문 방식은 앞에서 설명한 함수 리터럴 형태와 같다.  
여기서 주의할 점은 함수 선언문 방식으로 정의된 함수의 경우는 **반드시 함수명이 정의되어 있어야 한다.** 는 것이다.
```js
//add() 함수 선언문
function add(x, y){
    return x + y;
}

console.log(add(3, 4));     // (출력값 7)
```
함수 선언문 형태로 add() 함수를 구현한 코드이다.  
함수명 add가 있고, 또한 이 함수명으로 함수를 호출하고 있다.

### 4.1.3 함수 표현식 방식으로 함수 생성하기
자바스크립트에서는 함수도 하나의 값처럼 취급된다.(이러한 특징이 있으므로 자바스크립트의 함수는 일급 객체라고 한다.)  
따라서 함수도 숫자나 문자열처럼 변수에 할당하는 것이 가능하다.  

이런 방식으로 함수 리터럴로 하나의 함수를 만들고, 여기서 생성된 함수를 변수에 할당하여 함수를 생성하는 것을 **함수 표현식** 이라고 말한다.

```js
//add() 함수 표현식
var add = function(x, y){
    return x + y;
}
var plus = add;

console.log(add(3, 4));     // (출력값 7)
console.log(plus(5, 6));    // (출력값 11)
```
위 예제는 함수 변수 add가 실제로 참조하는 두 수를 더하는 함수의 이름이 없다.  
앞서 설명했듯이 이렇게 이름이 없는 함수 형태를 자바스크립트에서는 **익명함수** 라고 부른다.  
이것이 바로 **익명 함수를 이용한 함수 표현식 방법(익명 함수 표현식)** 이다.  

참고로 함수 이름이 포함된 함수 표현식을 **기명 함수 표현식** 이라 한다.  
이러한 기명 함수 표현식을 사용할 경우는 주의해야 할 점이 있다.

```js
//기명 함수 표현식의 함수 호출 방법
var add = function sum(x, y){
    return x + y;
};

console.log(add(3, 4));    // (출력값 7)
console.log(sum(5, 6));    // (출력값 Uncaught ReferenceError: sum is not defined 에러 발생)
```
위 예제에서 sum() 함수를 정의하고, 이 함수를 add 함수 변수에 할당했다.  
예제에서 특이한 점은 add() 함수 호출 결과값이 성공적으로 리턴된 반면에, sum() 함수 호출의 경우 에러가 발생한다는 것이다.  
**이것은 함수 표현식에서 사용된 함수 이름이 외부 코드에서 접근 불가능 하기 때문이다.**  

실제로 함수 표현식에 사용된 함수 이름은 정의된 함수 내부에서 해당 함수를 재귀적으로 호출하거나, 디버거 등에서 함수를 구분할 때 사용된다.  

위 예제와 같이 함수 선언문 형식으로 정의된 add() 함수는 자바스크립트 엔진에 의해 다음과 같은 함수 표현식 형태로 변경되기 때문이다.
```js
var add = function add(x, y){
    return x + y;
}
```
함수 이름과 함수 변수의 이름이 add로 같으므로, 함수 이름으로 함수가 호출되는 것처럼 보이지만, 실제로는 add 함수 변수로 함수 외부에서 호출이 가능하게 된 것이다.  

함수 표현식에서는 함수 이름이 선택 사항이지만, 이러한 함수 이름을 이용하면 함수 코드 내부에서 함수 이름으로 함수의 재귀적인 호출 처리가 가능하다.
```js
//함수 표현식 방식으로 구현한 팩토리얼 함수
var factorialVar = function factorial(n){
    if ( n <= 1) {
        return 1;
    }
    return n * factorial(n-1);
};

console.log(factorialVar(3));   // (출력값 6)
console.log(factorial(3));  // (출력값 출력값 Uncaught ReferenceError: sum is not defined 에러 발생)
```

### 4.1.4 Function() 생성자 함수를 통한 함수 생성하기
자바스크립트의 함수도 Function()이라는 기본 내장 생성자 함수로부터 생성된 **객체** 라 볼 수 있다.  
앞에서 설명한 함수 선언문이나 함수 표현식 방식도 Function() 생성자 함수가 아닌 함수 리터럴 방식으로 함수를 생성하지만, 결국엔 이 또한 내부적으로는 Function() 생성자 함수로 함수가 생성된다고 볼 수 있다.

>new Function (arg1, arg2, ... argN, functionBody)
>- arg1, arg2,...,argN - 함수의 매개변수
>- functionBody - 함수가 호출될 때 실행될 코드를 포함한 문자열

```js
//Function() 생성자 함수를 이용한 add() 함수 생성
var add = new Function('x', 'y', 'return x + y');

console.log(add(3, 4));     // (출력값 7)
```

### 4.1.5 함수 호이스팅
지금까지 자바스크립트에서 함수를 생성하는 3가지 방법을 살펴봤다.  
코드는 약간씩 다르지만 서로 모두 같은 기능의 함수를 생성함을 확인할 수 있다.  
하지만 이들 사이에는 동작 방식이 약간 차이가 있다.  
그중의 하나가 바로 **함수 호이스팅** 이다.

```js
//함수 선언문 방식과 함수 호이스팅
add(2, 3);  // (출력값 5)

//함수 선언문 형태로 add() 함수 정의
function add(x, y){
    return x + y;
}

add(5, 6);  // (출력값 11)
```
함수가 자신이 위치한 코드에 상관없이 **함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작한다.** 는 것을 확인할 수 있다.  
이것을 **함수 호이스팅** 이라고 부른다.

```js
add(2, 3);  // (출력값 Uncaught TypeError: add is not a function)

//함수 표현식 방식과 함수 호이스팅
var add = function (x, y){
    return x + y;
}

add(5, 6);  // (출력값 11)
```
add(2, 3); --> add() 함수를 호출한 시점에서 아직 add() 함수가 생성되기 전이므로 에러가 발생한다.
add(5, 6); --> add() 함수를 호출한 시점에서 add() 함수가 생성되 있으므로 정삭 동작 한다.

**함수 호이스팅이 발생하는 원인**

<small>자바스크립트의 **변수 생성** 과 **초기화** 작업이 분리돼서 진행되기 때문이다.</small>

## [4.2 함수 객체 : 함수도 객체다](./chapter04-02.md)
